// Package kube provides a client for interacting with jobs and pods through the KubeAPI in a single namespace
// Originally Generated by Claude 3.5 Sonnet
package kube

import (
	"context"
	"fmt"
	"time"

	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/kubernetes"
)

// ClientInterface defines the interface for Kubernetes operations. This interface exists
// to aid in testing.
type ClientInterface interface {
	GetNamespace() string
	SetNamespace(namespace string)
	CreateJob(ctx context.Context, job *batchv1.Job) (*batchv1.Job, error)
	CleanupJob(ctx context.Context, jobName string) error
	DeleteJob(ctx context.Context, jobName string) error
	WaitForJobCompletion(ctx context.Context, jobName string) error
	GetJobLogs(ctx context.Context, jobName string) (string, error)
}

// Client represents a Kubernetes Client
type Client struct {
	clientset kubernetes.Interface
	namespace string
}

// NewClient creates a new Kubernetes client from a clientset
func NewClient(clientset kubernetes.Interface) (*Client, error) {
	return &Client{
		clientset: clientset,
		namespace: "default",
	}, nil
}

// SetNamespace sets the namespace for the client
func (c *Client) SetNamespace(namespace string) {
	c.namespace = namespace
}

// GetNamespace returns the configured namespace for the client
func (c *Client) GetNamespace() string {
	return c.namespace
}

// CreateJob creates a Kubernetes Job with the provided spec
func (c *Client) CreateJob(ctx context.Context, job *batchv1.Job) (*batchv1.Job, error) {
	// Sanity check
	if job.Name == "" {
		return nil, fmt.Errorf("job name is empty")
	}

	return c.clientset.BatchV1().Jobs(c.namespace).Create(ctx, job, metav1.CreateOptions{})
}

// GetJob retrieves a Kubernetes Job by name
func (c *Client) GetJob(ctx context.Context, jobName string) (*batchv1.Job, error) {
	return c.clientset.BatchV1().Jobs(c.namespace).Get(ctx, jobName, metav1.GetOptions{})
}

// DeleteJob deletes a Kubernetes Job by name
func (c *Client) DeleteJob(ctx context.Context, jobName string) error {
	propagationPolicy := metav1.DeletePropagationForeground
	return c.clientset.BatchV1().Jobs(c.namespace).Delete(ctx, jobName, metav1.DeleteOptions{PropagationPolicy: &propagationPolicy})
}

// WatchJob watches a Kubernetes Job for changes
func (c *Client) WatchJob(ctx context.Context, jobName string) (watch.Interface, error) {
	return c.clientset.BatchV1().Jobs(c.namespace).Watch(ctx, metav1.ListOptions{
		FieldSelector: fmt.Sprintf("metadata.name=%s", jobName),
	})
}

// GetJobLogs retrieves logs from a Kubernetes Job's pods
func (c *Client) GetJobLogs(ctx context.Context, jobName string) (string, error) {
	// Get the pods for this job
	pods, err := c.clientset.CoreV1().Pods(c.namespace).List(ctx, metav1.ListOptions{
		LabelSelector: fmt.Sprintf("job-name=%s", jobName),
	})
	if err != nil {
		return "", fmt.Errorf("failed to list pods for job %s: %w", jobName, err)
	}

	if len(pods.Items) == 0 {
		return "", fmt.Errorf("no pods found for job %s", jobName)
	}

	// Get logs from the first pod (assuming single pod job)
	// If a Job can try >1 time, this will not handle that scenario, and needs to be adjusted.
	pod := pods.Items[0]
	logs, err := c.clientset.CoreV1().Pods(c.namespace).GetLogs(pod.Name, &corev1.PodLogOptions{}).Do(ctx).Raw()
	if err != nil {
		return "", fmt.Errorf("failed to get logs for pod %s: %w", pod.Name, err)
	}

	return string(logs), nil
}

// WaitForJobCompletion waits for a job to complete (succeed or fail). It's context-aware,
// so set ctx to something like `context.WithTimeout(ctx, 10*time.Second)` to set a timeout.
func (c *Client) WaitForJobCompletion(ctx context.Context, jobName string) error {
	watcher, err := c.WatchJob(ctx, jobName)
	if err != nil {
		return fmt.Errorf("failed to watch job %s: %w", jobName, err)
	}
	defer watcher.Stop()

	for {
		select {
		case <-ctx.Done():
			return fmt.Errorf("context cancelled while waiting for job %s to complete", jobName)
		case event := <-watcher.ResultChan():
			job, ok := event.Object.(*batchv1.Job)
			if !ok {
				continue
			}

			jobStatus := getJobStatus(job)
			if jobStatus == batchv1.JobComplete || jobStatus == batchv1.JobSuccessCriteriaMet {
				return nil
			}
			if jobStatus == batchv1.JobFailed || jobStatus == batchv1.JobFailureTarget {
				return fmt.Errorf("job %s failed", jobName)
			}
		}
	}
}

// CleanupJob deletes a job and polls the KubeAPI until deletion is confirmed. It's
// context-aware, so set ctx to something like `context.WithTimeout(ctx, 10*time.Second)`
// to set a timeout.
func (c *Client) CleanupJob(ctx context.Context, jobName string) error {
	// Delete the job (this will also delete the pods due to cascading deletion)
	err := c.DeleteJob(ctx, jobName)
	if err != nil {
		return fmt.Errorf("failed to delete job %s: %w", jobName, err)
	}

	// Poll for job deletion instead of using a watcher to avoid infinite loops
	for {
		select {
		case <-ctx.Done():
			return fmt.Errorf("context cancelled waiting for job %s to be deleted", jobName)
		default:
			// Check if job still exists
			_, err := c.GetJob(ctx, jobName)
			if errors.IsNotFound(err) {
				return nil
			}
			if err != nil {
				return fmt.Errorf("error checking if job %s was deleted: %w", jobName, err)
			}
			// Wait a bit before checking again
			time.Sleep(500 * time.Millisecond)
		}
	}
}

// getJobStatus returns the status of a job (Completed, Failed, Suspended, etc.) or
// an empty string if the status is not yet available.
func getJobStatus(job *batchv1.Job) batchv1.JobConditionType {
	for _, condition := range job.Status.Conditions {
		if condition.Status == corev1.ConditionTrue {
			return condition.Type
		}
	}
	return ""
}
