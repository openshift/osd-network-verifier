// Provides a client for interacting with jobs and pods through the KubeAPI in a single namespace
// Generated by Claude 3.5 Sonnet
package kube

import (
	"context"
	"fmt"
	"time"

	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/kubernetes"
)

// Client represents a Kubernetes Client
type Client struct {
	clientset kubernetes.Interface
	namespace string
}

// NewClient creates a new Kubernetes client from a clientset
func NewClient(clientset *kubernetes.Clientset) (*Client, error) {
	return &Client{
		clientset: clientset,
		namespace: "default",
	}, nil
}

// SetNamespace sets the namespace for the client
func (c *Client) SetNamespace(namespace string) {
	c.namespace = namespace
}

// CreateJob creates a Kubernetes Job with the provided spec
func (c *Client) CreateJob(ctx context.Context, job *batchv1.Job) (*batchv1.Job, error) {
	// Sanity check
	if job.Name == "" {
		return nil, fmt.Errorf("job name is empty")
	}

	return c.clientset.BatchV1().Jobs(c.namespace).Create(ctx, job, metav1.CreateOptions{})
}

// GetJob retrieves a Kubernetes Job by name
func (c *Client) GetJob(ctx context.Context, jobName string) (*batchv1.Job, error) {
	return c.clientset.BatchV1().Jobs(c.namespace).Get(ctx, jobName, metav1.GetOptions{})
}

// DeleteJob deletes a Kubernetes Job by name
func (c *Client) DeleteJob(ctx context.Context, jobName string) error {
	propagationPolicy := metav1.DeletePropagationForeground
	return c.clientset.BatchV1().Jobs(c.namespace).Delete(ctx, jobName, metav1.DeleteOptions{PropagationPolicy: &propagationPolicy})
}

// WatchJob watches a Kubernetes Job for changes
func (c *Client) WatchJob(ctx context.Context, jobName string) (watch.Interface, error) {
	return c.clientset.BatchV1().Jobs(c.namespace).Watch(ctx, metav1.ListOptions{
		FieldSelector: fmt.Sprintf("metadata.name=%s", jobName),
	})
}

// GetJobLogs retrieves logs from a Kubernetes Job's pods
func (c *Client) GetJobLogs(ctx context.Context, jobName string) (string, error) {
	// Get the pods for this job
	pods, err := c.clientset.CoreV1().Pods(c.namespace).List(ctx, metav1.ListOptions{
		LabelSelector: fmt.Sprintf("job-name=%s", jobName),
	})
	if err != nil {
		return "", fmt.Errorf("failed to list pods for job %s: %w", jobName, err)
	}

	if len(pods.Items) == 0 {
		return "", fmt.Errorf("no pods found for job %s", jobName)
	}

	// Get logs from the first pod (assuming single pod job)
	pod := pods.Items[0]
	logs, err := c.clientset.CoreV1().Pods(c.namespace).GetLogs(pod.Name, &corev1.PodLogOptions{}).Do(ctx).Raw()
	if err != nil {
		return "", fmt.Errorf("failed to get logs for pod %s: %w", pod.Name, err)
	}

	return string(logs), nil
}

// WaitForJobCompletion waits for a job to complete (succeed or fail)
func (c *Client) WaitForJobCompletion(ctx context.Context, jobName string, timeout time.Duration) error {
	watcher, err := c.WatchJob(ctx, jobName)
	if err != nil {
		return fmt.Errorf("failed to watch job %s: %w", jobName, err)
	}
	defer watcher.Stop()

	timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	for {
		select {
		case <-timeoutCtx.Done():
			return fmt.Errorf("timeout waiting for job %s to complete", jobName)
		case event := <-watcher.ResultChan():
			job, ok := event.Object.(*batchv1.Job)
			if !ok {
				continue
			}

			// Check if job is complete
			if job.Status.Succeeded > 0 {
				return nil
			}
			if job.Status.Failed > 0 {
				return fmt.Errorf("job %s failed", jobName)
			}
		}
	}
}

// CleanupJob deletes a job and waits for the KubeAPI to let us know that it's gone
// TODO: this seems to take many seconds longer to return than the output of
// `oc get jobs -w --output-watch-events` implies the deletion takes. We should
// investigate why this is the case.
func (c *Client) CleanupJob(ctx context.Context, jobName string) error {
	// Delete the job (this will also delete the pods due to cascading deletion)
	err := c.DeleteJob(ctx, jobName)
	if err != nil {
		return fmt.Errorf("failed to delete job %s: %w", jobName, err)
	}

	// Wait for the job to be fully deleted
	watcher, err := c.WatchJob(ctx, jobName)
	if err != nil {
		// Job might already be deleted
		return nil
	}
	defer watcher.Stop()

	for {
		select {
		case event := <-watcher.ResultChan():
			if event.Type == watch.Deleted {
				return nil
			}
		case <-time.After(30 * time.Second):
			return fmt.Errorf("timeout waiting for job %s to be deleted", jobName)
		}
	}
}
